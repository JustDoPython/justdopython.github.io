---
layout: post
category: python
title: Python 正则原来要这样用
tagline: by 極光
tags:
  - 
---

![标题图](http://www.justdopython.com/assets/images/2021/06/python_re/1.png)

正则表达式相信大家应该都不陌生，本质上就是一种微小的、高度专业化的编程语言，使用它你可以为要匹配的可能字符串集指定规则。大多数编程语言正则语法基本相似，只是实现正则的函数库不同，今天就来跟大家一起了解下 Python 支持正则表达式的函数。

<!--more-->

## 简单应用

正则最简单的应用，就是对字符串进行操作，用来找出想要匹配的字符串，比如 `Python` 就只会匹配字符串 `Python` ，当然也可以设置不区分大小写，这样就可以匹配更多，比如 `python`、`pyThon`等。

如果还想来点复杂的匹配要怎么做，这就需要用到元字符了，下面就是所有的元字符：

```
   // 元字符
  [ ] ( ) . ^ $ * + ? { }  \ | 
```

## 元字符 `[ ] \`

这一对元字符主要用于指定字符类，也就是你想要匹配的一组字符。

比如： `[asd]` 就是要匹配任何字符 `a`, `s`, `d`，但如果想匹配 `a b c d e …… x y z` 是不是要把所有的都写一遍？ 当然不是了，这个我们可以写成 `[a-z]` 就行了，`-` 就是用来表示一个范围，再比如表示数字 1 至 9，可以写成 `[1-9]` 。

上面说的是包含的字符范围，如果想匹配不包含的范围要怎么做？这就要用到元字符 `^`，比如匹配除了 `n`, `u`, `3` 之外的字符，可以写成 `[^nu3]`。

还有一点需要注意，在 `[ ]` 中的元字符会作为普通字符匹配，比如 `[$+]` 就会匹配 `$`, `+`。

最后说下元字符 `\`，它的意议是用于转议所有元字符，也就是去掉元字符的特殊性，比如 `\{\$\\`，其实就是匹配字串 `{`, `$`, `\`。

## 特殊字符类

上面说了 `[a-z]` 可以匹配所有小写字母，`[0-9]` 用来匹配所有数字，这样已经够简单了，还有更简单的几种特殊范围表达方式。

|字符|说明|
|---|---|
|.|匹配除 "\n" 之外的任何单个字符。要匹配包括 '\n' 在内的任何字符，请使用象 '[.\n]' 的模式。|
|\d|相当于[0-9]，即匹配一个数字字符。|
|\D|相当于[^0-9],即匹配一个非数字字符。|
|\s|相当于[\f\n\r\t\v]，也就是匹配任何空白字符，包括空格、制表符、换页符等等。|
|\S|相当于[^\f\n\r\t\v]，匹配任何非空白字符。|
|\w|相当于[a-zA-Z0-9_]，匹配任何字母与数字字符。|
|\W|相当于[^a-zA-Z0-9_]，匹配任何非字母与数字字符。|

上面这些特殊序列可以包含在字符类中，比如 `[\s\d,]` 即匹配任何空白字符，数字和 `,`。

## 重复匹配 `* + ？ {m,n}`

只是做到匹配字符串集合，肯定是不够的，它还有个更大的优势，那就是可以指定某一部分字符是重复的，并且可以指定重复的次数。

先说第一个表示重复的元字符 `*`，它用来指定前面一个字符可以重复0次或者多次。

比如 `ap*le` 将会匹配 `apple`,`appple`,`ale` 等等。

这里当重复正则时，匹配引擎会尝试尽可能多的重复它。 当发现模式的后续部分不匹配，则匹配引擎将会回退并以较少的重复次数再次尝试。

另一个重复的元字符 `+`，它用来表示前一个字符可重复1次或多次。它跟 `*` 相比，其实就是少了一个重复0次，也就是上面 `ap*le` 换成 `ap+le` 不会出现匹配到 `ale`。

第三个元字符就是 `?`，它用来表示前一个字符可重复0次或1次，把上面的例子换成 `ap?le`，其实就是两个字符串 `ale` 或 `aple`。

最后一个复杂些就是 `{m,n}`，这个表示前一个字符可重复次数是一个区间，也就是最少重复m次，最多重复n次。

例如 `ap{2,3}le`将会匹配 `apple`,`appple` 两个字符串，其他都不会匹配。

在这里需要注意下，m 需要小于 n,当然 `m` 或 `n` 也是可以省略的。比如当 m=0 时，可以省略 m，当 n 为无穷大时，也可以省略 n。

## 如何使用？分两步

1. 编译

对！你没看错，如果想使用正则表达式，首先得要把它编译成模式对象。编译成对象后，它就可以使用各种操作方法了，比如字串匹配查询或替换等。

Python 编译的方法是 `re.compile('正则表达式')`，比如 `re.compile('ap?le')`。

当然也可以传一些特殊的参数，比如忽略大小写，那上面的编译方法就可以写成 `re.compile('ap?le', re.IGNORECASE)`，这样在匹配字串时就可以忽略大小写了。

那除了这个还有别的参数吗？有，下面我把一部分常用的参数列出来，对了参数还可以简写，比如刚才使用的 `re.IGNORECASE` 可以简写成 `re.I`，这样就方便多了。

以下是常用编译参数：
| 参数 | 简写| 说明|
|-----|-----|-----|
|IGNORECASE| `I` | 忽略大小写|
|ASCII|  `A`|  使几个转义(`\w`、`\b`、`\s`和`\d`)匹配仅与具有相应特征属性的 `ASCII` 字符匹配|
|DOTALL| `S` | 使 `.` 匹配任何字符，包括换行符|
|LOCALE| `L` | 进行区域设置感知匹配|
|MULTILINE | `M` | 多行匹配，影响 `^` 和 `$` |
|VERBOSE | `X` | 忽略正则字符串中的空格，除非空格位于字符类中或前面带有未转义的反斜杠，可以组织和缩进，还可以写注释|

大部分都容易理解，只是最后一个参数 `VERBOSE` 可能不太容易理解，这里给大家个官方的例子看下就理解了。

```
test = re.compile(r"""
 &[#]                # 数字开始部分
 (
     0[0-7]+         # 八进制
   | [0-9]+          # 小数形式
   | x[0-9a-fA-F]+   # 十六进制
 )
 ;                   # 结束分号
""", re.VERBOSE)
```

2. 查找匹配

其实上面说的编译都只是在做准备，准备接下来要介绍的，正则表达式最重要的查询匹配。

常用匹配方法：

- match()：当是从字符串的开头开始匹配时使用，如匹配不上返回`None`；
- search()：通过扫描字符串，来匹配字符串任意位置，如匹配不上返回`None`；
- findall()：这个方法返回的是个列表，即所有匹配上的字符串列表；
- finditer()：这个和 findall() 相同，只是不是返回列表，而是一个 iterator。

上面这些方法，如果匹配成功，会返回一个对象实例，其中包含匹配相关的信息：起始和终结位置、匹配的子串以及其它信息。

```
// 示例代码
import re
ret = re.compile('[0-9]+') 
ret.match("apple")    // 返回 None   
ret.match("12189")   // 返回 <re.Match object; span=(0, 5), match='12189'>
ret.match("121ab")   // 返回 <re.Match object; span=(0, 3), match='121'>

```

## 总结

好了，今天我们简单介绍了下正则表达式，以及在 Python 中如何使用正则表达式，其实以上这些只是基础，后续还会为大家介绍更多。OK，今天就聊这些，如果你喜欢记得点 `在看`。
